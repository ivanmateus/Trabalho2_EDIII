//Felipe Tiago de Carli - 10525686
//Gabriel de Andrade Dezan - 10525706
//Ivan Mateus de Lima Azevedo - 10525602

#include <stdio.h>
#include <stdlib.h>
#include "programaTrab2.h"
#include "./src/adjList.h"
#include "./src/escreverNaTela.h"

//Compare if two int arrays are equal
//(i.e. have the same values in the same positions)
int compareArrays(int a[], int b[], int size)	{
	for(int i = 0; i < size; ++i){
    //If two different values were found,
    //return 0
		if(a[i] != b[i]){
			return 0;
    }
	}
  //If the arrays are equal, return 1
	return 1;
}

//Print the results of the Djikstra algorithm
void printDjikstra(int origin, int D[], int ANT[], indexList *graphIndex){
  //Get the index node of the origin
  indexNode *index = searchByIndex(origin, graphIndex);
  //Calculate the number of cities (vertices) in the graph
  int length = indexLength(graphIndex);
  for(int i = 0; i < length; ++i) {
    //If the current index is equals to the origin
    if(i != origin){
      //Then get its index node
      indexNode *aux = searchByIndex(i, graphIndex);
      //And its antecessor's index node
      indexNode *ant = searchByIndex(ANT[i], graphIndex);
      //And print the corresponding values of the origin
      printf("%s %s ", index->cidade, index->estado);
      //Of the current index
      printf("%s %s ", aux->cidade, aux->estado);
      //The calculated distance in the distance array generated by the algorithm
      printf("%d ", D[i]);
      //And the corresponding values of the antecessor
      printf("%s %s\n", ant->cidade, ant->estado);
    }
  }
}

//Executes the Djikstra algorithm
int djikstra(int origin, int *D, int *ANT, adjList *G, indexList *graphIndex) {
  //If the given origin is -1, it means that the
  //search for the city in the index list didn't found
  //any city, so stop the execution
  if(origin == -1){
    printf("Cidade inexistente.\n");
    return 0;
  }

  //Calculate the number of vertices
  int length = indexLength(graphIndex);
  //Create two variables:
  //V: is the array with all the cities
  //S: is the array with the cities that were already
  //evalued in the algorithm
  int S[length], V[length];
  //Put the origin in the S array
  S[origin] = origin;
  //And put distance 0 in the origin's position
  D[origin] = 0;
  //Initiate the arrays V and S
  for(int i = 0; i < length; ++i) {
    //V will receive all vertices
    V[i] = i;
    //And S will receive -1 in all positions
    //except for origin, that has been set already
    if(i != origin) {
      S[i] = -1;
    }
  }

  //Get the adjacency list of the origin
  adjNode *aux = G[origin];
  //And initialize the D and ANT arrays
  while(aux != NULL){
    //To the adjacent vertices, put the
    //distances in the D array
    D[aux->index] = aux->distancia;
    //And set the origin as their antecessor
    ANT[aux->index] = origin;
    aux = aux->next;
  }

  //While the S and V arrays aren't equal
  while(!compareArrays(S, V, length)){
    //Variable to store the minimum weight vertice
    int min = 0;
    //Search for an initial value of minimum
    //that is in the S array (has been evalued already)
    //For the first iteration, this value will be the same as the origin
    while(S[min] != -1){
      ++min;
    }
    //For all the vertices in the graph
    for(int i = 0; i < length; ++i){
      //If the current vertice is not the minimum and
      //its distance is less than the minimum's one
      //and if the vertice hasn't been evalued yet (S[i] == -1)
      //Else, if the distance is the same, the minimum
      //will be the less vertice
      if(i != min && D[i] < D[min] && S[i] == -1){
        //Then make it the minimum
        min = i;
      } else if (i != min && D[i] == D[min] && S[i] == -1) {
        //If the less is i, then min is i, otherwise, keep the same
        min = i < min ? i : min;
      }
    }
    //After a minimum was found, put it in the S array
    //to simbolize it was evalued
    S[min] = min;
    //Get the adjacency list for the minimum
    aux = G[min];
    //And for all the adjacent vertices
    while(aux != NULL){
      //If the distance of the current index is different
      //of the distance of the min + the weight of the current index
      if(D[aux->index] != D[min] + aux->distancia){
        //And if the distance of the min + the weight of the current index
        //is less than the distance of the current index
        if(D[min] + aux->distancia < D[aux->index]){
          //Set it as the new distance
          D[aux->index] = D[min] + aux->distancia;
          //And make min the antecessor
          ANT[aux->index] = min;
        }        
      }
      aux = aux->next;
    }
  }
  return 1;
}

//Check if a vertice is inside a component
int isVInComponent(int U[], int V){
  if(U[V] != -1){
    return 1;
  }
  return 0;
}

//Execute the Prim's minimum spanning tree algorithm
int prim(int origin, adjList *G, adjList *minTree, indexList *graphIndex, int length){
  if(origin == -1){
    printf("Cidade inexistente.\n");
    return 0;
  }
  int U[length], V[length];
  U[origin] = origin;
  for(int i = 0; i < length; ++i) {
    V[i] = i;
    if(i != origin) {
      U[i] = -1;
    }
  }

  while(!compareArrays(U, V, length)){
    int u = -1;
    int v = -1;
    adjNode *minWEdge = NULL;
    for(int i = 0; i < length; ++i){
      if(isVInComponent(U, i)){
        adjNode *aux = (G[i])->next;
        while(aux != NULL){
          if(!isVInComponent(U, aux->index)){
            if(minWEdge == NULL){
              minWEdge = aux;
              u = i;
              v = minWEdge->index;
            } else if(aux->distancia != minWEdge->distancia){
              if(aux->distancia < minWEdge->distancia){
                minWEdge = aux;
                u = i;
                v = minWEdge->index;
              }
            } else if(aux->distancia == minWEdge->distancia){
              if((i < u) || (i == u && aux->index < v)){
                minWEdge = aux;
                u = i;
                v = minWEdge->index;
              }
            }
            aux = aux->next;
          } else {
            aux = aux->next;
          }
        }
      }
    }
    dataReg *reg = (dataReg *)malloc(sizeof(dataReg));
    strcpy(reg->estadoOrigem,G[u]->estado);
    strcpy(reg->estadoDestino,minWEdge->estado);
    reg->distancia = minWEdge->distancia;
    reg->cidadeOrigem = G[u]->cidade;
    reg->cidadeDestino = minWEdge->cidade;
    reg->tempoViagem = minWEdge->tempoViagem;
    insertAdjList(reg, &minTree[searchByCity(reg->cidadeOrigem,graphIndex)], graphIndex, 0);
    insertAdjList(reg, &minTree[searchByCity(reg->cidadeDestino,graphIndex)], graphIndex, 1);
    U[v] = v;
  }
  return 1;
}

int main(void){
  char arqInp[50];
  char field[15];
	char *cidadeOrigem = (char *)malloc(sizeof(char *));
	int option = -1;
	scanf("%d %s",&option, arqInp);

  //Build the index list that maps the cities
  indexList *graphIndex = (indexList *)malloc(sizeof(indexList));
	*graphIndex = NULL;
  buildIndex(arqInp, graphIndex);
  int length = indexLength(graphIndex);

  //Initialize the adjacency list with each city mapped in the index above
  adjList *G = (adjList *)malloc(sizeof(adjList *) * length);
  initAdjList(G, length);

  adjList *T = (adjList *)malloc(sizeof(adjList *) * length);
  *T = NULL;
  initAdjList(T, length);

  int D[length], ANT[length];
  for(int i = 0; i < length; ++i) {
    ANT[i] = -1;
    D[i] = 999999999;
  }

  switch (option)	{
		case 9:
      buildAdjList(arqInp, G, graphIndex);			
	    printAdjList(G, graphIndex);
      break;

    case 10:
			scanf("%s",field);
			scan_quote_string(cidadeOrigem);
      if(buildAdjList(arqInp, G, graphIndex)){
        if(djikstra(searchByCity(cidadeOrigem, graphIndex), D, ANT, G, graphIndex)){
          printDjikstra(searchByCity(cidadeOrigem, graphIndex), D, ANT, graphIndex);
        }
      }
      break;

    case 11:
			scanf("%s",field);
			scan_quote_string(cidadeOrigem);
      if(buildAdjList(arqInp, G, graphIndex)){
        if(prim(searchByCity(cidadeOrigem, graphIndex), G, T, graphIndex, length)){
          printAdjList(T,graphIndex);
        }
      }
      break;

		default:
			break;
	}
  return 0;
}